grammar Query;
options {
  superClass = BaseParser;
}
@header{
package org.tzi.use.query;
import org.tzi.use.query.ast.*;
import org.tzi.use.parser.base.*;
import org.tzi.use.parser.base.BaseParser;
import org.tzi.use.parser.ocl.*;
import org.tzi.use.parser.soil.ast.*;
import java.util.Collections;
import java.util.Arrays;
}

@lexer::header {
package org.tzi.use.query;
import org.tzi.use.query.ast.*;
import org.tzi.use.parser.ParseErrorHandler;
}
@lexer::members {
    private ParseErrorHandler fParseErrorHandler;

    public String getFilename() {
        return fParseErrorHandler.getFileName();
    }
    
    @Override
    public String getErrorHeader(RecognitionException e) {
    	return "line " + e.line + ":" + e.charPositionInLine;
    }
    	
    public void emitErrorMessage(String msg) {
        fParseErrorHandler.reportError(msg);
    }
 
    public void init(ParseErrorHandler handler) {
        fParseErrorHandler = handler;
    }
}

checkExpr returns [QAst expr]:
    'verify' qexpr=queryExpr {$expr=qexpr;}
         (
            ('&&' right_expr=queryExpr 
                {
                    $expr = new QueryBinaryExpr($expr, right_expr, Connective.AND);
                }
            )
        |
            ('||' right_expr=queryExpr 
                {
                    $expr = new QueryBinaryExpr($expr, right_expr, Connective.OR);
                }
            )
        |
            ( '=>' right_expr = queryExpr
                {
                    $expr = new QueryBinaryExpr($expr, right_expr, Connective.IMPLIES);
                }
            )
         )* EOF
    |
        mexpr=moduleExpr {$expr = new ModuleListExpr(); ((ModuleListExpr)$expr).addModule(mexpr);} 
        (mexpr=moduleExpr {((ModuleListExpr)$expr).addModule(mexpr);})* EOF
;

queryExpr returns [QueryExpr qexpr] @init{
    qexpr = new QueryExpr();
}: 
    'select' f=featureExpr {$qexpr.addFeature(f);} (COMMA f=featureExpr {$qexpr.addFeature(f);})* 
        (with=withExpr {$qexpr.addWithExpr(with);})? 
        (without=butExpr {$qexpr.addWithoutExpr(without);})? ('inject' o=oclExpr {$qexpr.setOCLExpression(o);})?
        ('as' name=IDENT {$qexpr.setAlias($name.getText());}) ?
   | alias = IDENT {$qexpr.setAlias($alias.getText());}
;
 
//queryExpr_nl:
 //   queryExpr '&&' queryExpr
  //  | queryExpr '||' queryExpr
//;
featureExpr returns [QFeatureExpr feature]: 
    (modifier=modifiers) ? dest=(IDENT|STAR) (k=rankExpr)?
    {
        $feature = (k>0) ?
                    new QClassExpr($dest.getText(),modifier,k)
                    :
                    new QClassExpr($dest.getText(),modifier)
                    ;
    }
    | f1 = attrExpr {$feature=f1;}
    | f2 = assocExpr {$feature=f2;}
;

modifiers returns [Modifier m]:
    'only' {$m=Modifier.ONLY;}
    |
    'no' {$m=Modifier.NO;}

    |'all' {$m=Modifier.NO;}
;
attrExpr returns [QAttrExpr attr]:
    src=(IDENT|STAR) DOT dest=(IDENT|STAR) (k=rankExpr)? 
    {
        attr = (k>0) ? 
               new QAttrExpr($src.getText(),$dest.getText(),k)
               :
               new QAttrExpr($src.getText(),$dest.getText())
               ;
    }
;

assocExpr returns [QAssocExpr assoc]
: src=(IDENT|STAR) COLON name=(IDENT|STAR) COLON dest=(IDENT|STAR) (k=rankExpr)?
    {
        assoc = (k>0) ? 
                new QAssocExpr($src.getText(),$name.getText(),$dest.getText(),k) 
                :
                new QAssocExpr($src.getText(),$name.getText(),$dest.getText())
                ;
    }
;

withExpr returns [QWithExpr with] @init{
    $with = new QWithExpr();
}: 
    'with' w=invExpr{$with.addInvExpr(w);} (COMMA w=invExpr{$with.addInvExpr(w);})*
;
butExpr returns [QButExpr without] @init{
    $without = new QButExpr();
}
:
    'but' w=invExpr{$without.addInvExpr(w);} (COMMA w=invExpr{$without.addInvExpr(w);})*
;

invExpr returns [QInvExpr inv]: 
    src=(IDENT|STAR) COLON_COLON dest=(IDENT|STAR) (k=rankExpr)? 
    {
        
        inv =   (k>0) ? 
                new QInvExpr($src.getText(),$dest.getText(),k)
                :
                new QInvExpr($src.getText(),$dest.getText())
                ;
    }
;

rankExpr returns [int rank] @init{
    $rank=0;
 }:
    AT k=INT {$rank=Integer.parseInt($k.text);}
;

moduleExpr returns [ModuleExpr mexpr]:
    'module' name=IDENT {$mexpr = new ModuleExpr($name.getText());}
        query=queryExpr {$mexpr.addQuery(query);} 
        (query=queryExpr {$mexpr.addQuery(query);})*
    'end'
;

oclExpr returns [QOCLExpr ocl_expr] @init{
    $ocl_expr = new QOCLExpr();
}: 
    LBRACE expr=expression (k=rankExpr)? 
    {
        if (k>0)
            $ocl_expr.addOCLExpression(expr,k);
        else
            $ocl_expr.addOCLExpression(expr);
    } 
    (COMMA expr=expression (k=rankExpr)? 
        {
            if (k>0)
                $ocl_expr.addOCLExpression(expr,k);
            else
                $ocl_expr.addOCLExpression(expr);
        }
    )* RBRACE
;