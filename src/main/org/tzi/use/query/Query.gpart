grammar Query;
options {
  superClass = BaseParser;
}
@header{
package org.tzi.use.query;
import org.tzi.use.query.ast.*;
import org.tzi.use.parser.base.*;
import org.tzi.use.parser.base.BaseParser;
import org.tzi.use.parser.ocl.*;
import org.tzi.use.parser.soil.ast.*;
import java.util.Collections;
import java.util.Arrays;
}
 
@lexer::header {
package org.tzi.use.query;
import org.tzi.use.query.ast.*;
import org.tzi.use.parser.ParseErrorHandler;
}
@lexer::members {
    private ParseErrorHandler fParseErrorHandler;

    public String getFilename() {
        return fParseErrorHandler.getFileName();
    }
    
    @Override
    public String getErrorHeader(RecognitionException e) {
    	return "line " + e.line + ":" + e.charPositionInLine;
    }
    	
    public void emitErrorMessage(String msg) {
        fParseErrorHandler.reportError(msg);
    }
 
    public void init(ParseErrorHandler handler) {
        fParseErrorHandler = handler;
    }
}

checkExpr returns [QAst expr]:
    'verify' qexpr=queryExpr {$expr=qexpr;}
         (
            ('&&' right_expr=queryExpr 
                {
                    $expr = new QueryBinaryExpr($expr, right_expr, Connective.AND);
                }
            )
        |
            ('||' right_expr=queryExpr 
                {
                    $expr = new QueryBinaryExpr($expr, right_expr, Connective.OR);
                }
            )
        |
            ( '=>' right_expr = queryExpr
                {
                    $expr = new QueryBinaryExpr($expr, right_expr, Connective.IMPLIES);
                }
            )

        )* 
        
        EOF
;

queryExpr returns [QueryExpr qexpr] @init{
    qexpr = new QueryExpr();
}: 
    'select' f=featureExpr {$qexpr.addFeature(f);} (COMMA f=featureExpr {$qexpr.addFeature(f);})* 
        (with=withExpr {$qexpr.addWithExpr(with);})? 
        (without=butExpr {$qexpr.addWithoutExpr(without);})? (oclExpr)? 
        ('as' name=IDENT {$qexpr.setAlias($name.getText());}) ?
   | alias = IDENT {$qexpr.setAlias($alias.getText());}
;

//queryExpr_nl:
 //   queryExpr '&&' queryExpr
  //  | queryExpr '||' queryExpr
//;
featureExpr returns [QFeatureExpr feature]: 
    (modifier=modifiers) ? dest=(IDENT|STAR)
    {
        $feature= new QClassExpr($dest.getText(),modifier);
    }
    | f1 = attrExpr {$feature=f1;}
    | f2 = assocExpr {$feature=f2;}
;

modifiers returns [Modifier m]:
    'only' {$m=Modifier.ONLY;}
    |
    'no' {$m=Modifier.NO;}

    |'all' {$m=Modifier.NO;}
;
attrExpr returns [QAttrExpr attr]:
    src=(IDENT|STAR) DOT dest=(IDENT|STAR) {attr = new QAttrExpr($src.getText(),$dest.getText());}
;

assocExpr returns [QAssocExpr assoc]
: src=(IDENT|STAR) COLON name=(IDENT|STAR) COLON dest=(IDENT|STAR)
    {assoc = new QAssocExpr($src.getText(),$name.getText(),$dest.getText());}
;

withExpr returns [QWithExpr with] @init{
    $with = new QWithExpr();
}: 
    'with' w=invExpr{$with.addInvExpr(w);} (COMMA w=invExpr{$with.addInvExpr(w);})*
;
butExpr returns [QButExpr without] @init{
    $without = new QButExpr();
}
:
    'but' w=invExpr{$without.addInvExpr(w);} (COMMA w=invExpr{$without.addInvExpr(w);})*
;

invExpr returns [QInvExpr inv]: 
    src=(IDENT|STAR) COLON_COLON dest=(IDENT|STAR) {inv = new QInvExpr($src.getText(),$dest.getText());}
;

oclExpr: 'withocl' 
    expression
;